> 注意，本题的各种式子乍一看很凌乱，但是仔细推敲会发现都不难得到，所以在看到代码中的长串表达式时，请不要放弃。

#### 题目

​	小C和小T设计了一个新游戏！小T有一个长度为N的序列，并把它分成许多子序列，每个子序列都有Ｋ个数，Ｎ是K的倍数。第一个子序列是第１～Ｋ个数,第二个子序列是第K+1～2K个数,以此类推. 

​	小C让小T对序列进行一些操作,包括以下两种类型: 

​	      操作1.将每一个子序列中的数向左/向右轮换x个位置.(只在子序列里轮换位置) 

​	      操作2.将整个序列上的数向左/向右轮换x个位置. 

​	注意操作2可以改变每个数所属的子序列.进行完所有操作之后,小T把最终序列给小C,小C的任务就是找出小T原来的的序列.请你帮助他! 

#### 思路

>  **前置条件**
>
> 由于块的移动是循环的，所以，我们不妨将所有的向左移动转化为向右移动（显然）



我们将块中的元素标上号。

以块大小为4为例：

> 1234|1234|1234|1234|123.....

首先可以明确一点，块中元素的标号种类是永远不会改变的。（显然）

无论是整体移动还是块内移动，每次当前元素一移除本块，就会另外有元素补充进来。

如上述序列向右移动一格将变为：

> 4123|4123|4123|4123...

那么，我们如果知道了第一个块中的第一个元素，就可以顺推出其他的元素。

每个块的第一个元素的信息很好维护：
$$
now=((now-1-step) mod K+K)modK+1
$$
那我们就成功解决了只有块内移动的情况。

下面思考，如果是整体移动的话，那么每一个块中的一部分标号都是从其他块中“抢”过来的。

就拿上面的序列：

>  4123|4123|4123|4123...

每一个块中的“4”都来自于上一个块。

那么我们现在还要解决的问题就是当前块中的标号来源是它左边的哪一个块。（显然）



差分即可：

首先找到离当前点最远的那个块与当前块的距离：

$lef=(step-1)/K+1;$

当前的尾部：

$tail=((now+K-1)%K+K)%K$

最远的那个点的坐标：

$ tmp = ((now-1-step)modK+K)modK+1$

那么在$[tmp,tail]$这段区间，移动的就是$lef$

在$[now,(tmp-2+K)modK+1]$这段区间，移动的就是$lef-1$

```
[...tmp..tail].....[......][......][now......]
       lef     ....     2       1    
```



最后再计算答案就行了。

```cpp
#include<bits/stdc++.h>
#define M 100005
using namespace std;
int n,K,q,A[M],bc;//块数量 
int Q[M][2];
int dif[M],now;//now维护每个块中第一个元素之编号 
void update(int l,int r,int step){//差分维护块内信息 
	if(l<=r){
		dif[l]-=step;
		dif[r+1]+=step;	
	}
	else {
		update(l,K,step);
		update(1,r,step);	
	}
}
int main(){
	cin>>n>>K>>q;
	bc=n/K;//块的个数 
	for(int i=1;i<=q;i++)scanf("%d%d",&Q[i][0],&Q[i][1]),Q[i][1]=((-Q[i][1])%n+n)%n;//把向左移的转化为向右移的
	for(int i=0;i<n;i++)scanf("%d",&A[i]);
	now=1;//当前每个块的头部编号 
	for(int i=q;i>=1;i--){
		if(Q[i][1]==0)continue;
		if(Q[i][0]==1)now=((now-1-Q[i][1])%K+K)%K+1;//移动一波块内
		else {
			int lef=(Q[i][1]-1)/K+1;//最远移动了几个块（到哪）
			int tmp=((now-1-Q[i][1])%K+K)%K+1;//最远的那个点在哪 
			int tail=((now+K-1)%K+K)%K;if(tail==0)tail=K;
			update(tmp,tail,lef);
			if(Q[i][1]%K!=0&&lef>1)update(now,(tmp-2+K)%K+1,lef-1);
			now=tmp;
		}
	}
	for(int i=1;i<=K;i++){
		dif[i]+=dif[i-1];
		dif[i]=(dif[i]+bc)%bc;
	}
	for(int i=0;i<n;i++){
		int tmp=(now+i%K+K-1)%K+1;//块中的编号 
		int nowid=i/K;
		nowid=((nowid+dif[tmp])%bc+bc)%bc;//原块编号
		printf("%d ",A[nowid*K+tmp-1]);
	}
	return 0;
}
```

