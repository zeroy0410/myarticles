---
Title: HDU4532 湫秋系列故事——安排座位(dp)
tags: [dp,数学]
---

#### 题目

  	为了给腾讯公司找到更多优秀的人才，HR湫秋最近去某高校组织了一次针对该校所有系的聚会，邀请了每个系的一些优秀学生来参加。

　　作为组织者，湫秋要安排他们的座位。这并不是一件很简单的事情，因为只有一排位置，并且位置总数恰好等于参加聚会的人数。为了促进交流，两个来自相同系的同学不可以座位相邻。湫秋现在希望知道有多少种不同的合理安排座位的方法（任意两个合理的安排方法，只要有一个位置的同学不同，都被认为是不同的）。  

#### 前言

学长出的卷子里有问题求解有这道题，当时的题目数据范围最大n只有3，我当时的想法是用$dp[i][j][k][f]$表示当前状态三种人分别剩余的数目，以及最后放的是哪个人的种数。然而这样即使是做那道题，状态数也有$3*3*3*3$对于人手模拟来说极其庞大，所以当时直接跳了。

看了学长的题解之后，发现原来状态可以缩减至$n*n$所以来做此题。

#### 思路

我们用$dp[i][k]$表示到了第$i$个节点，前面已经有$k$个连成一片（pair）的方案数。

显然需要用组合数转移。

我们在当前层枚举破坏了上层的几对pair,同时增加了几对pair，这样就可以转移了。



思考，对于当前这$A[i]$个点来说，我们用了$k$个点来破坏上层，

那么还剩下的$res=A[i]-k$

又有$r$个点来增加pair，所以最后用于做“基础设施”的点为$res-r$个

那么最后的$r$个点就是每放一个，就增加一对pair了。



如果上一层是有$j$对pair

那么对于$k$来说，有$C_j^k$种选择

对于$res-r$来说，有$C_{sum[i-1]+1-j}^{res-r}$种选择。

对于最后的$r$个点，则在前面的"基础设施"旁边随便放，是一个整数拆分。



剩下就是阶乘的处理，显然由乘法分配律，我们先加完再乘和加上的同时乘是一样的，所以转移收尾直接乘就行了。

这样转移就好了。

```c++
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int MOD=1e9+7;
int T;
int n,dp[555][555],A[55];
int C[1005][1005],fac[55],sum[55];
/*
dp[i][k]定义为考虑了放了前i种颜色的球，一共有k个同色球连在一起的方案数。
*/ 
void Init(){
    fac[0]=1;
    for(int i=1;i<=47;i++)
        fac[i]=1LL*fac[i-1]*i%MOD; 
    C[0][0]=1;
    for(int i=1;i<=1000;i++){
        C[i][0]=1;
        for(int j=1;j<=i;j++){
            C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
        }
    }
}
int main(){
    cin>>T;int cas=0;
    Init();
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&A[i]);
        sum[0]=0;
        for(int i=1;i<=n;i++)sum[i]=sum[i-1]+A[i];
        memset(dp,0,sizeof(dp));
        dp[1][A[1]-1]=fac[A[1]];
        for(int i=2;i<=n;i++){
            for(int j=0;j<=sum[i-1]-1;j++){//上层有多少个空
                for(int k=0;k<=A[i]-1;k++){//本层加了多少
                    for(int r=0;r<=j;r++){//本层减了多少
                        if(A[i]-r<k)break;
                        int x=A[i]-r;//这些是剩余的点
                        dp[i][j+k-r]+=1LL*dp[i-1][j]*C[j][r]%MOD*C[sum[i-1]-j+1][x-k]%MOD*C[A[i]-1][k]%MOD*fac[A[i]]%MOD;
                        dp[i][j+k-r]%=MOD;
                    }
                }
            }
        }
        printf("Case %d: %d\n",++cas,(dp[n][0]+MOD)%MOD);
    }
    return 0;    
}
```