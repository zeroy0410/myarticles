---
title: NOIP2017 列队
date: 2018-10-02 08:06:44
tags: [树状数组]
---

#### 题目

[题目链接](https://www.luogu.org/problemnew/show/P3960)

#### 思路

30% 直接暴力模拟。

50% 离散，模拟

80% 注意x=1那一档，可以维护一棵树状数组，每删除一个点，就把树状数组上的点删除，再把它放在最后，每次询问在树状数组+二分。

**正解1**
<!--more-->
还是树状数组，由70分的代码扩展而来。

先不要管内存。一种自然的想法是每一行维护一个树状数组，再维护最后一列新加入元素，但是这样显然会MLE。所以，我们如何只用1棵树状数组就完成所有操作呢？

首先，我们开一个$d[]$数组，维护当前行的询问是当前行的第几个元素（每一行用一次树状数组）

这里代码并不复杂：

```c++
for(int i=1;i<=n;i++){
    for(int j=0;j<(int)P[i].size();j++){
        node x=P[i][j];
        d[x.id]=find(x.p);
        T.add(d[x.id],-1);
    }
    for(int j=0;j<(int)P[i].size();j++){
        node x=P[i][j];
        T.add(d[x.id],1);
    }
}
```

现在这棵树状数组维护行的信息的使命已经完结，它现在要维护列的信息。

我们用$h[]$,vector维护每一行新加进来的元素。

用$lst$，vector维护最后一列的新加入的元素。

就可以实现询问查询了。

```c++
for(int i=1;i<=Q;i++){
    int t=q[i][0];
    int cur=find(t);//当前行目前的最后一列是哪个元素（树状数组的角色已经转变） 
    T.add(cur,-1);
    if(cur<=n)ans=1LL*cur*m;//如果它是在n之前，说明它是原有的元素 
    else ans=lst[cur-n-1];//反之，说明它是新加的元素，存在lst数组中 
    //上面处理完了最后一列的情况 
    if(q[i][1]!=m){
        h[q[i][0]].push_back(ans);//当前行又新加入了一个元素 
        if(d[i]<m)ans=1LL*(q[i][0]-1)*m+d[i];//就是原来的点 
        else ans=h[q[i][0]][d[i]-m];//是最后一列补进来的点 
    }
    lst.push_back(ans);//把它放在最后一列的尾部 
    printf("%lld\n",ans);
}
```

(完整代码就不放了)

**正解2**

动态加点线段树。

接着延续上述思路。

之前注意到的如果搞n棵树状数组，那么会MLE，现在我们把n棵树状数组替换成动点线段树