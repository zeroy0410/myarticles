---
title: 并查集的运用
date: 2018-08-30 10:18:15
tags: 并查集
---
#### 概述
并查集作为一种简洁而优美的数据结构~~主要是因为代码短~~,在信息学竞赛中一直有着很广泛的应用。

主要来看，并查集有以下5类：

1. 扩展域
2. 带权并查集
3. 按秩合并
4. 启发式合并
5. 可持久化并查集

~~坑要慢慢地填~~
<!--more-->
其实并查集的功能很简单，就是应用路径压缩的思想，不断地将树扁平化，从而实现降低时间复杂度的目的。

```
graph LR;
    A-->B;
    B-->C;
    C-->D;
    D-->E;
    A-->E;
```
在进行了一次getfa操作后，原图就会变成：

```
graph LR;
    D-->E;
    C-->E;
    B-->E;
    A-->E;
```

从而实现路径压缩，起到降低复杂度的作用。

模板如下：
```c++
int getfa(int x){
	return fa[x]==x?x:fa[x]=getfa(fa[x]);
}

bool Same(int x,int y){
	return getfa(x)==getfa(y);
} 

void Union(int x,int y){
	int r1=getfa(x),r2=getfa(y);
	if(r1!=r2)fa[r1]=r2;
}

```
很简洁而优美。
#### 1.扩展域

并查集能实现的功能很简单，无非就是“并”，“查”，都是对于集合之间的操作，但是，我们却可以认为地对其赋予新的含义。

比如，**如何表示两个元素不在一个集合?**,答案是使用**扩展域**,我们按照需求多开几倍的数组，比如上面这个问题，我们就可以单纯地令$x+n$表示与`$x$`不相交的集合。
这样我们就可以同时维护一个集合的许多信息。

例题：POJ1733等

#### 2.带权并查集

会了带权并查集其实就会发现，其实上面的扩展域就是对于带权并查集的模拟。带权并查集我们将每一个点赋予一个权值，并且在两个集合归并的时候，将前者的dis作一个更新处理，这样在每个元素下次getfa的时候，都会受到其先前fa的**波及**,这是其最重要的思想。

```
graph LR;
    dis_a-->dis_r1;
    dis_r1-->dis_r2;

```

在一次getfa之后：


```
graph LR
dis_a-->dis_r2
dis_r1-->dis_r2

```

要注意的是，在合并的过程中dis_r2的信息必须在重复叠加时不产生影响，一般情况下都赋为0，这样在+，或者^的时候，都不用担心被重复统计。

#### 3.按秩合并

这是为了让所生成的那棵树永远只有logn层，从而实现一个非常优雅的树。在这棵树上，我们几乎可以为所欲为（LCA都可以暴力跳）。

实现的方法是，对于对于两个根节点来说，我们总是将深度小的接到深度大的上面去（注意这里的深度不是根节点的深度，而是根节点向下延伸的长度），这样形成的树就比较优雅了。

```c++
int getfa(int x){
    return fa[x]==x?x:getfa(fa[x]);
}
void Union(int x,int y,int c){
    int r1=getfa(x),r2=getfa(y);
    if(r1!=r2){
        if(dep[r1]<=dep[r2]){
            fa[r1]=r2;
            eg[r1]=c;
            if(dep[r1]==dep[r2])dep[r2]++; 
        }
        else {
            fa[r2]=r1;
            eg[r2]=c;
        }
    }
}
```




    
    